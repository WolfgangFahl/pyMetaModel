{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pyMetaModel API Documentation","text":""},{"location":"#meta.metamodel","title":"<code>metamodel</code>","text":"<p>Created on 2022-11-23</p> <p>@author: wf</p>"},{"location":"#meta.metamodel.Context","title":"<code>Context</code>","text":"<p>               Bases: <code>MetaModelElement</code></p> <p>A Context groups some topics like a Namespace/Package. This class provides helper functions and constants to render a Context to corresponding wiki pages</p> Source code in <code>meta/metamodel.py</code> <pre><code>class Context(MetaModelElement):\n    \"\"\"\n    A Context groups some topics like a Namespace/Package.\n    This class provides helper functions and constants to render a Context to corresponding wiki pages\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        MetaModelElement.__init__(self)\n        self.topics = {}\n        self.errors = []\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"name\": \"MetaModel\",\n                \"since\": datetime.strptime(\"2015-01-23\", \"%Y-%m-%d\"),\n                \"copyright\": \"2015-2024 BITPlan GmbH\",\n                \"master\": \"http://smw-meta.bitplan.com\",\n            }\n        ]\n        return samples\n\n    def error(self, msg):\n        print(msg, file=sys.stderr)\n        self.errors.append(msg)\n\n    def lookupTopic(self, topic_name: str, purpose: str) -&gt; \"Topic\":\n        \"\"\"\n        lookup the given topic_name in my topics for the given purpose\n\n        Args:\n            topic_name(str): the name of the topic to lookup\n            purpose(str): the purpose to do the lookup for\n\n        Returns:\n            Topic: the topic if found else None and an error is added to my errors\n        \"\"\"\n        if topic_name in self.topics:\n            return self.topics[topic_name]\n        else:\n            self.error(\n                f\"\"\"topic {topic_name} not found in context {getattr(self,\"name\",\"?\")} for {purpose}\"\"\"\n            )\n            return None\n\n    def propertyAlreadyDeclared(\n        self, prop_name: str, topic: \"Topic\", purpose: str\n    ) -&gt; bool:\n        \"\"\"\n        check whether the given property or role name is already Declared\n\n        Args:\n            prop_name(str): the property to check for duplicates\n            topic(Topic): the topic to check\n            purpose(str): the purpose to be displayed in error messages\n\n        Returns:\n            bool: True if this prop_name has already been use\n        \"\"\"\n        in_use = prop_name in topic.properties or prop_name in topic.targetTopicLinks\n        if in_use:\n            self.error(\n                f\"duplicate name {prop_name} in topic {topic.name} for {purpose}\"\n            )\n        return in_use\n\n    def link_source_with_target(\n        self, tl: \"TopicLink\", source: \"Topic\", target: \"Topic\"\n    ):\n        \"\"\"\n        link the source with the target via the given topicLink\n\n        Args:\n            tl(TopicLink): the topicLink\n            source(Topic): the source Topic\n            target(Topic): the target Topic\n        \"\"\"\n        ok = True\n        ok = ok and not self.propertyAlreadyDeclared(\n            tl.sourceRole, target, f\"{tl.name}\"\n        )\n        ok = ok and not self.propertyAlreadyDeclared(\n            tl.targetRole, source, f\"{tl.name}\"\n        )\n        if ok:\n            # n:m handling with two lists on each side\n            source.sourceTopicLinks[tl.sourceRole] = tl\n            source.targetTopicLinks[tl.targetRole] = tl\n\n    def addLink(self, tl: \"TopicLink\"):\n        \"\"\"\n        link source and target of the given topicLink\n\n        Args:\n            tl(TopicLink): the topicLink\n            context(Context): the context in which the link \"lives\"\n        \"\"\"\n        tl.sourceTopic = self.lookupTopic(tl.source, f\"topicLink {tl.name}\")\n        tl.targetTopic = self.lookupTopic(tl.target, f\"topicLink {tl.name}\")\n        if tl.targetTopic is not None and tl.sourceTopic is not None:\n            self.link_source_with_target(tl, tl.sourceTopic, tl.targetTopic)\n\n    def addProperty(self, prop: \"Property\") -&gt; bool:\n        \"\"\"\n        add the given property to this context\n\n        Args:\n            prop(Property): the property to add\n\n        Returns:\n            bool: True if the property adding was successful\n        \"\"\"\n        if not hasattr(prop, \"topic\"):\n            self.error(f\"prop  {prop} has no topic\")\n            return False\n        topic_name = prop.topic\n        if not hasattr(prop, \"name\"):\n            self.error(f\"prop {prop} has no name\")\n            return False\n        if not hasattr(prop, \"type\"):\n            prop.type = \"Text\"\n        topic = self.lookupTopic(topic_name, f\"property {prop.name}\")\n        if topic:\n            topic.properties[prop.name] = prop\n            return True\n\n    def createProperty4TopicLink(self, tl: \"TopicLink\") -&gt; \"Property\":\n        \"\"\"\n        create a property for the given topic link\n\n        Args:\n            tl: TopicLink - the topiclink to create a property for\n        \"\"\"\n        # see https://wiki.bitplan.com/index.php/SiDIFTemplates#properties\n        prop = Property()\n        prop.name = tl.sourceRole\n        prop.label = prop.name\n        if hasattr(tl, \"sourceDocumentation\"):\n            prop.documentation = tl.sourceDocumentation\n        else:\n            prop.documentation = f\"{prop.name}\"\n        prop.topic = tl.target\n        prop.type = \"Page\"\n        prop.topicLink = tl\n        prop.isLink = True\n        return prop\n\n    @classmethod\n    def fromDictOfDicts(cls, did: dict) -&gt; \"Context\":\n        \"\"\"\n        fill me from the given dict of dicts\n\n        Args:\n            did(dict): the dict of dicts\n\n        Returns:\n            Context: the context read\n        \"\"\"\n        context = None\n        for _key, record in did.items():\n            isA = record[\"isA\"]\n            if isA == \"Context\":\n                context = Context()\n                context.fromDict(record)\n            elif isA == \"TopicLink\":\n                \"\"\"\n                # Event n\u00a0: 1 City\n                Event_in_City isA TopicLink\n                \"eventInCity\" is name of it\n                \"city\" is sourceRole of it\n                false is sourceMultiple of it\n                \"City\" is source of it\n                \"event\" is targetRole of it\n                true is targetMultiple of it\n                \"Event\" is target of it\n                \"\"\"\n                tl = TopicLink()\n                tl.fromDict(record)\n                context.addLink(tl)\n            elif isA == \"Property\":\n                prop = Property()\n                prop.isLink = False\n                prop.fromDict(record)\n                context.addProperty(prop)\n            else:  # isA == Topic or in declared topics\n                topic = Topic()\n                topic.fromDict(record)\n                if context is None:\n                    context = Context()\n                    context.name = \"GeneralContext\"\n                    context.since = \"2022-11-26\"\n                    context.master = \"http://master.bitplan.com\"\n                    context.error(f\"topic {topic.name} has no defined context\")\n                if hasattr(topic, \"name\"):\n                    context.topics[topic.name] = topic\n                else:\n                    context.error(f\"missing name for topic {topic}\")\n\n        # link topic to concepts and add topicLinks\n        for topic in context.topics.values():\n            topic.setConceptProperty()\n            for _tl_name, tl in topic.targetTopicLinks.items():\n                prop = context.createProperty4TopicLink(tl)\n                context.addProperty(prop)\n                pass\n        return context\n\n    @classmethod\n    def fromSiDIF_input(cls, sidif_input: str, debug: bool = False):\n        \"\"\"\n        initialize me from the given SiDIF input which might be a file path\n        or url\n\n        Args:\n            sidif_input: path to local file or URL\n            debug(bool): if True swith debugging on\n\n        Returns:\n            Tuple[Context,str,str]: context, error and errorMessage\n        \"\"\"\n        if sidif_input.startswith(\"http:\") or sidif_input.startswith(\"https:\"):\n            url = sidif_input\n            http = urllib3.PoolManager()\n            response = http.request(\"GET\", url)\n            sidif = response.data.decode(\"utf-8\")\n        else:\n            sidif_path = sidif_input\n            with open(sidif_path, \"r\") as sidif_file:\n                sidif = sidif_file.read()\n        return Context.fromSiDIF(sidif, title=sidif_input, debug=debug)\n\n    @classmethod\n    def fromSiDIF(\n        cls, sidif: str, title: str, depth: int = None, debug: bool = False\n    ) -&gt; typing.Tuple[\"Context\", object, str]:\n        \"\"\"\n        initialize me from the given SiDIF markup\n\n        Args:\n            sidif(str): the SiDIF markup to parse\n            title(str): the title for the SiDIF\n            depth(int): the explain depth to show for the errorMessage\n            debug(bool): if True handle debugging\n\n        Returns:\n            Tuple[Context,str,str]: context, error and errorMessage\n\n        \"\"\"\n        errMsg = None\n        context = None\n        sp = SiDIFParser(debug=debug)\n        parsed, error = sp.parseText(sidif, title, depth=depth)\n        if debug:\n            sp.printResult(parsed)\n        if error is None:\n            dif = parsed[0]\n            did = dif.toDictOfDicts()\n            context = Context.fromDictOfDicts(did)\n            context.dif = dif\n            context.did = did\n        else:\n            errMsg = sp.errorMessage(title, error, depth=depth)\n        return context, error, errMsg\n\n    @classmethod\n    def fromWikiContext(\n        cls, mw_context: MediaWikiContext, depth: int = None, debug: bool = False\n    ) -&gt; Tuple[\"Context\", Optional[Exception], Optional[str]]:\n        \"\"\"\n        initialize me from the given MediaWiki Context\n\n        Args:\n            mw_context(MediaWikiContext): the Mediawiki context\n            depth(int): the explain depth to show for the errorMessage\n            debug(bool): if True handle debugging\n\n        Return:\n            tuple(Context,Exception,str): the metamodel and potential parsing errors as Exception and error Message\n        \"\"\"\n        context = None\n        error = None\n        errMsg = None\n        sidif = None\n        if debug:\n            print(f\"reading sidif for {mw_context.context} from {mw_context.wikiId}\")\n        try:\n            sidif = mw_context.read_sidif()\n        except BaseException as ex:\n            error = ex\n            errMsg = str(ex)\n        if sidif is not None:\n            context, error, errMsg = cls.fromSiDIF(\n                sidif=sidif, title=mw_context.wikiId, depth=depth, debug=debug\n            )\n        return context, error, errMsg\n</code></pre>"},{"location":"#meta.metamodel.Context.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>meta/metamodel.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    MetaModelElement.__init__(self)\n    self.topics = {}\n    self.errors = []\n</code></pre>"},{"location":"#meta.metamodel.Context.addLink","title":"<code>addLink(tl)</code>","text":"<p>link source and target of the given topicLink</p> <p>Parameters:</p> Name Type Description Default <code>tl(TopicLink)</code> <p>the topicLink</p> required <code>context(Context)</code> <p>the context in which the link \"lives\"</p> required Source code in <code>meta/metamodel.py</code> <pre><code>def addLink(self, tl: \"TopicLink\"):\n    \"\"\"\n    link source and target of the given topicLink\n\n    Args:\n        tl(TopicLink): the topicLink\n        context(Context): the context in which the link \"lives\"\n    \"\"\"\n    tl.sourceTopic = self.lookupTopic(tl.source, f\"topicLink {tl.name}\")\n    tl.targetTopic = self.lookupTopic(tl.target, f\"topicLink {tl.name}\")\n    if tl.targetTopic is not None and tl.sourceTopic is not None:\n        self.link_source_with_target(tl, tl.sourceTopic, tl.targetTopic)\n</code></pre>"},{"location":"#meta.metamodel.Context.addProperty","title":"<code>addProperty(prop)</code>","text":"<p>add the given property to this context</p> <p>Parameters:</p> Name Type Description Default <code>prop(Property)</code> <p>the property to add</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the property adding was successful</p> Source code in <code>meta/metamodel.py</code> <pre><code>def addProperty(self, prop: \"Property\") -&gt; bool:\n    \"\"\"\n    add the given property to this context\n\n    Args:\n        prop(Property): the property to add\n\n    Returns:\n        bool: True if the property adding was successful\n    \"\"\"\n    if not hasattr(prop, \"topic\"):\n        self.error(f\"prop  {prop} has no topic\")\n        return False\n    topic_name = prop.topic\n    if not hasattr(prop, \"name\"):\n        self.error(f\"prop {prop} has no name\")\n        return False\n    if not hasattr(prop, \"type\"):\n        prop.type = \"Text\"\n    topic = self.lookupTopic(topic_name, f\"property {prop.name}\")\n    if topic:\n        topic.properties[prop.name] = prop\n        return True\n</code></pre>"},{"location":"#meta.metamodel.Context.createProperty4TopicLink","title":"<code>createProperty4TopicLink(tl)</code>","text":"<p>create a property for the given topic link</p> <p>Parameters:</p> Name Type Description Default <code>tl</code> <code>TopicLink</code> <p>TopicLink - the topiclink to create a property for</p> required Source code in <code>meta/metamodel.py</code> <pre><code>def createProperty4TopicLink(self, tl: \"TopicLink\") -&gt; \"Property\":\n    \"\"\"\n    create a property for the given topic link\n\n    Args:\n        tl: TopicLink - the topiclink to create a property for\n    \"\"\"\n    # see https://wiki.bitplan.com/index.php/SiDIFTemplates#properties\n    prop = Property()\n    prop.name = tl.sourceRole\n    prop.label = prop.name\n    if hasattr(tl, \"sourceDocumentation\"):\n        prop.documentation = tl.sourceDocumentation\n    else:\n        prop.documentation = f\"{prop.name}\"\n    prop.topic = tl.target\n    prop.type = \"Page\"\n    prop.topicLink = tl\n    prop.isLink = True\n    return prop\n</code></pre>"},{"location":"#meta.metamodel.Context.fromDictOfDicts","title":"<code>fromDictOfDicts(did)</code>  <code>classmethod</code>","text":"<p>fill me from the given dict of dicts</p> <p>Parameters:</p> Name Type Description Default <code>did(dict)</code> <p>the dict of dicts</p> required <p>Returns:</p> Name Type Description <code>Context</code> <code>Context</code> <p>the context read</p> Source code in <code>meta/metamodel.py</code> <pre><code>@classmethod\ndef fromDictOfDicts(cls, did: dict) -&gt; \"Context\":\n    \"\"\"\n    fill me from the given dict of dicts\n\n    Args:\n        did(dict): the dict of dicts\n\n    Returns:\n        Context: the context read\n    \"\"\"\n    context = None\n    for _key, record in did.items():\n        isA = record[\"isA\"]\n        if isA == \"Context\":\n            context = Context()\n            context.fromDict(record)\n        elif isA == \"TopicLink\":\n            \"\"\"\n            # Event n\u00a0: 1 City\n            Event_in_City isA TopicLink\n            \"eventInCity\" is name of it\n            \"city\" is sourceRole of it\n            false is sourceMultiple of it\n            \"City\" is source of it\n            \"event\" is targetRole of it\n            true is targetMultiple of it\n            \"Event\" is target of it\n            \"\"\"\n            tl = TopicLink()\n            tl.fromDict(record)\n            context.addLink(tl)\n        elif isA == \"Property\":\n            prop = Property()\n            prop.isLink = False\n            prop.fromDict(record)\n            context.addProperty(prop)\n        else:  # isA == Topic or in declared topics\n            topic = Topic()\n            topic.fromDict(record)\n            if context is None:\n                context = Context()\n                context.name = \"GeneralContext\"\n                context.since = \"2022-11-26\"\n                context.master = \"http://master.bitplan.com\"\n                context.error(f\"topic {topic.name} has no defined context\")\n            if hasattr(topic, \"name\"):\n                context.topics[topic.name] = topic\n            else:\n                context.error(f\"missing name for topic {topic}\")\n\n    # link topic to concepts and add topicLinks\n    for topic in context.topics.values():\n        topic.setConceptProperty()\n        for _tl_name, tl in topic.targetTopicLinks.items():\n            prop = context.createProperty4TopicLink(tl)\n            context.addProperty(prop)\n            pass\n    return context\n</code></pre>"},{"location":"#meta.metamodel.Context.fromSiDIF","title":"<code>fromSiDIF(sidif, title, depth=None, debug=False)</code>  <code>classmethod</code>","text":"<p>initialize me from the given SiDIF markup</p> <p>Parameters:</p> Name Type Description Default <code>sidif(str)</code> <p>the SiDIF markup to parse</p> required <code>title(str)</code> <p>the title for the SiDIF</p> required <code>depth(int)</code> <p>the explain depth to show for the errorMessage</p> required <code>debug(bool)</code> <p>if True handle debugging</p> required <p>Returns:</p> Type Description <code>Tuple[Context, object, str]</code> <p>Tuple[Context,str,str]: context, error and errorMessage</p> Source code in <code>meta/metamodel.py</code> <pre><code>@classmethod\ndef fromSiDIF(\n    cls, sidif: str, title: str, depth: int = None, debug: bool = False\n) -&gt; typing.Tuple[\"Context\", object, str]:\n    \"\"\"\n    initialize me from the given SiDIF markup\n\n    Args:\n        sidif(str): the SiDIF markup to parse\n        title(str): the title for the SiDIF\n        depth(int): the explain depth to show for the errorMessage\n        debug(bool): if True handle debugging\n\n    Returns:\n        Tuple[Context,str,str]: context, error and errorMessage\n\n    \"\"\"\n    errMsg = None\n    context = None\n    sp = SiDIFParser(debug=debug)\n    parsed, error = sp.parseText(sidif, title, depth=depth)\n    if debug:\n        sp.printResult(parsed)\n    if error is None:\n        dif = parsed[0]\n        did = dif.toDictOfDicts()\n        context = Context.fromDictOfDicts(did)\n        context.dif = dif\n        context.did = did\n    else:\n        errMsg = sp.errorMessage(title, error, depth=depth)\n    return context, error, errMsg\n</code></pre>"},{"location":"#meta.metamodel.Context.fromSiDIF_input","title":"<code>fromSiDIF_input(sidif_input, debug=False)</code>  <code>classmethod</code>","text":"<p>initialize me from the given SiDIF input which might be a file path or url</p> <p>Parameters:</p> Name Type Description Default <code>sidif_input</code> <code>str</code> <p>path to local file or URL</p> required <code>debug(bool)</code> <p>if True swith debugging on</p> required <p>Returns:</p> Type Description <p>Tuple[Context,str,str]: context, error and errorMessage</p> Source code in <code>meta/metamodel.py</code> <pre><code>@classmethod\ndef fromSiDIF_input(cls, sidif_input: str, debug: bool = False):\n    \"\"\"\n    initialize me from the given SiDIF input which might be a file path\n    or url\n\n    Args:\n        sidif_input: path to local file or URL\n        debug(bool): if True swith debugging on\n\n    Returns:\n        Tuple[Context,str,str]: context, error and errorMessage\n    \"\"\"\n    if sidif_input.startswith(\"http:\") or sidif_input.startswith(\"https:\"):\n        url = sidif_input\n        http = urllib3.PoolManager()\n        response = http.request(\"GET\", url)\n        sidif = response.data.decode(\"utf-8\")\n    else:\n        sidif_path = sidif_input\n        with open(sidif_path, \"r\") as sidif_file:\n            sidif = sidif_file.read()\n    return Context.fromSiDIF(sidif, title=sidif_input, debug=debug)\n</code></pre>"},{"location":"#meta.metamodel.Context.fromWikiContext","title":"<code>fromWikiContext(mw_context, depth=None, debug=False)</code>  <code>classmethod</code>","text":"<p>initialize me from the given MediaWiki Context</p> <p>Parameters:</p> Name Type Description Default <code>mw_context(MediaWikiContext)</code> <p>the Mediawiki context</p> required <code>depth(int)</code> <p>the explain depth to show for the errorMessage</p> required <code>debug(bool)</code> <p>if True handle debugging</p> required Return <p>tuple(Context,Exception,str): the metamodel and potential parsing errors as Exception and error Message</p> Source code in <code>meta/metamodel.py</code> <pre><code>@classmethod\ndef fromWikiContext(\n    cls, mw_context: MediaWikiContext, depth: int = None, debug: bool = False\n) -&gt; Tuple[\"Context\", Optional[Exception], Optional[str]]:\n    \"\"\"\n    initialize me from the given MediaWiki Context\n\n    Args:\n        mw_context(MediaWikiContext): the Mediawiki context\n        depth(int): the explain depth to show for the errorMessage\n        debug(bool): if True handle debugging\n\n    Return:\n        tuple(Context,Exception,str): the metamodel and potential parsing errors as Exception and error Message\n    \"\"\"\n    context = None\n    error = None\n    errMsg = None\n    sidif = None\n    if debug:\n        print(f\"reading sidif for {mw_context.context} from {mw_context.wikiId}\")\n    try:\n        sidif = mw_context.read_sidif()\n    except BaseException as ex:\n        error = ex\n        errMsg = str(ex)\n    if sidif is not None:\n        context, error, errMsg = cls.fromSiDIF(\n            sidif=sidif, title=mw_context.wikiId, depth=depth, debug=debug\n        )\n    return context, error, errMsg\n</code></pre>"},{"location":"#meta.metamodel.Context.link_source_with_target","title":"<code>link_source_with_target(tl, source, target)</code>","text":"<p>link the source with the target via the given topicLink</p> <p>Parameters:</p> Name Type Description Default <code>tl(TopicLink)</code> <p>the topicLink</p> required <code>source(Topic)</code> <p>the source Topic</p> required <code>target(Topic)</code> <p>the target Topic</p> required Source code in <code>meta/metamodel.py</code> <pre><code>def link_source_with_target(\n    self, tl: \"TopicLink\", source: \"Topic\", target: \"Topic\"\n):\n    \"\"\"\n    link the source with the target via the given topicLink\n\n    Args:\n        tl(TopicLink): the topicLink\n        source(Topic): the source Topic\n        target(Topic): the target Topic\n    \"\"\"\n    ok = True\n    ok = ok and not self.propertyAlreadyDeclared(\n        tl.sourceRole, target, f\"{tl.name}\"\n    )\n    ok = ok and not self.propertyAlreadyDeclared(\n        tl.targetRole, source, f\"{tl.name}\"\n    )\n    if ok:\n        # n:m handling with two lists on each side\n        source.sourceTopicLinks[tl.sourceRole] = tl\n        source.targetTopicLinks[tl.targetRole] = tl\n</code></pre>"},{"location":"#meta.metamodel.Context.lookupTopic","title":"<code>lookupTopic(topic_name, purpose)</code>","text":"<p>lookup the given topic_name in my topics for the given purpose</p> <p>Parameters:</p> Name Type Description Default <code>topic_name(str)</code> <p>the name of the topic to lookup</p> required <code>purpose(str)</code> <p>the purpose to do the lookup for</p> required <p>Returns:</p> Name Type Description <code>Topic</code> <code>Topic</code> <p>the topic if found else None and an error is added to my errors</p> Source code in <code>meta/metamodel.py</code> <pre><code>def lookupTopic(self, topic_name: str, purpose: str) -&gt; \"Topic\":\n    \"\"\"\n    lookup the given topic_name in my topics for the given purpose\n\n    Args:\n        topic_name(str): the name of the topic to lookup\n        purpose(str): the purpose to do the lookup for\n\n    Returns:\n        Topic: the topic if found else None and an error is added to my errors\n    \"\"\"\n    if topic_name in self.topics:\n        return self.topics[topic_name]\n    else:\n        self.error(\n            f\"\"\"topic {topic_name} not found in context {getattr(self,\"name\",\"?\")} for {purpose}\"\"\"\n        )\n        return None\n</code></pre>"},{"location":"#meta.metamodel.Context.propertyAlreadyDeclared","title":"<code>propertyAlreadyDeclared(prop_name, topic, purpose)</code>","text":"<p>check whether the given property or role name is already Declared</p> <p>Parameters:</p> Name Type Description Default <code>prop_name(str)</code> <p>the property to check for duplicates</p> required <code>topic(Topic)</code> <p>the topic to check</p> required <code>purpose(str)</code> <p>the purpose to be displayed in error messages</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if this prop_name has already been use</p> Source code in <code>meta/metamodel.py</code> <pre><code>def propertyAlreadyDeclared(\n    self, prop_name: str, topic: \"Topic\", purpose: str\n) -&gt; bool:\n    \"\"\"\n    check whether the given property or role name is already Declared\n\n    Args:\n        prop_name(str): the property to check for duplicates\n        topic(Topic): the topic to check\n        purpose(str): the purpose to be displayed in error messages\n\n    Returns:\n        bool: True if this prop_name has already been use\n    \"\"\"\n    in_use = prop_name in topic.properties or prop_name in topic.targetTopicLinks\n    if in_use:\n        self.error(\n            f\"duplicate name {prop_name} in topic {topic.name} for {purpose}\"\n        )\n    return in_use\n</code></pre>"},{"location":"#meta.metamodel.MetaModelElement","title":"<code>MetaModelElement</code>","text":"<p>               Bases: <code>JSONAble</code></p> <p>a generic MetaModelElement</p> <p>to handle the technicalities of being a MetaModelElement so that derived MetaModelElements can focus on the MetaModel domain specific aspects</p> Source code in <code>meta/metamodel.py</code> <pre><code>class MetaModelElement(JSONAble):\n    \"\"\"\n    a generic MetaModelElement\n\n    to handle the technicalities of being a MetaModelElement so that derived\n    MetaModelElements can focus on the MetaModel domain specific aspects\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        construct me\n        \"\"\"\n        self.__metamodel_props = {}\n        cls = self.__class__\n        if hasattr(cls, \"getSamples\"):\n            for sample in cls.getSamples():\n                for key in sample.keys():\n                    if not key in self.__metamodel_props:\n                        self.__metamodel_props[key] = key  # Property(self,key)\n\n    def __str__(self):\n        \"\"\"\n        get a string representation of me\n        \"\"\"\n        text = self.__class__.__name__\n        for prop_name in self.__metamodel_props.keys():\n            if not isinstance(prop_name, str):\n                pass\n            elif hasattr(self, prop_name):\n                value = getattr(self, prop_name)\n                text += f\"\\n  {prop_name}={str(value)}\"\n        return text\n</code></pre>"},{"location":"#meta.metamodel.MetaModelElement.__init__","title":"<code>__init__()</code>","text":"<p>construct me</p> Source code in <code>meta/metamodel.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    construct me\n    \"\"\"\n    self.__metamodel_props = {}\n    cls = self.__class__\n    if hasattr(cls, \"getSamples\"):\n        for sample in cls.getSamples():\n            for key in sample.keys():\n                if not key in self.__metamodel_props:\n                    self.__metamodel_props[key] = key  # Property(self,key)\n</code></pre>"},{"location":"#meta.metamodel.MetaModelElement.__str__","title":"<code>__str__()</code>","text":"<p>get a string representation of me</p> Source code in <code>meta/metamodel.py</code> <pre><code>def __str__(self):\n    \"\"\"\n    get a string representation of me\n    \"\"\"\n    text = self.__class__.__name__\n    for prop_name in self.__metamodel_props.keys():\n        if not isinstance(prop_name, str):\n            pass\n        elif hasattr(self, prop_name):\n            value = getattr(self, prop_name)\n            text += f\"\\n  {prop_name}={str(value)}\"\n    return text\n</code></pre>"},{"location":"#meta.metamodel.Property","title":"<code>Property</code>","text":"<p>               Bases: <code>MetaModelElement</code></p> <p>Provides helper functions and constants for properties</p> Source code in <code>meta/metamodel.py</code> <pre><code>class Property(MetaModelElement):\n    \"\"\"\n    Provides helper functions and constants for properties\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        MetaModelElement.__init__(self)\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"name\": \"Title\",\n                \"label\": \"Offical Name\",\n                \"type\": \"Special:Types/Text\",\n                \"index\": 2,\n                \"sortPos\": 2,\n                \"primaryKey\": False,\n                \"mandatory\": True,\n                \"namespace\": \"Test\",\n                \"size\": 25,\n                \"uploadable\": False,\n                \"defaultValue\": \"Some Title\",\n                \"inputType\": \"combobox\",\n                \"allowedVaues\": \"Tile A, Title B\",\n                \"documentation\": \" Documentation can contain\\n line breaks\",\n                \"values_from\": \"property=Title\",\n                \"showInGrid\": False,\n                \"isLink\": False,\n                \"nullable\": False,\n                \"topic\": \"Concept:Event\",\n            },\n            {\n                \"name\": \"wikidataid\",\n                \"type\": \"Special:Types/External identifier\",\n                \"formatterURI\": \"https://www.wikidata.org/wiki/$1\",\n            },\n            # Properties that are not included in the MetaModel\n            {\n                \"placeholder\": \"e.g. SMWCon\",\n                \"regexp\": \"NaturalNumber\",\n                \"usedFor\": \"Concept:Event, Concept:Event series\",\n                \"pageTitle\": \"Property:Title\",\n            },\n        ]\n        return samples\n</code></pre>"},{"location":"#meta.metamodel.Property.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>meta/metamodel.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    MetaModelElement.__init__(self)\n</code></pre>"},{"location":"#meta.metamodel.Topic","title":"<code>Topic</code>","text":"<p>               Bases: <code>MetaModelElement</code></p> <p>A Topic is a Concept/Class/Thing/Entity</p> Source code in <code>meta/metamodel.py</code> <pre><code>class Topic(MetaModelElement):\n    \"\"\"\n    A Topic is a Concept/Class/Thing/Entity\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        constructor\n        \"\"\"\n        MetaModelElement.__init__(self)\n        self._pluralName = (\n            None  # Initialize with underscore to indicate a protected attribute\n        )\n\n        self.properties = {}\n        self.sourceTopicLinks = {}\n        self.targetTopicLinks = {}\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"pageTitle\": \"Concept:Topic\",\n                \"name\": \"Topic\",\n                \"pluralName\": \"Topics\",\n                \"icon\": \"File:Topic_icon.png\",\n                \"iconUrl\": \"/images/a/ae/Index.png\",\n                \"documentation\": \"A Topic is a Concept/Class/Thing/Entity\",\n                \"wikiDocumentation\": \"A Topic is a Concept/Class/Thing/Entity\",\n                \"context\": \"MetaModel\",\n                \"listLimit\": 7,\n                \"cargo\": True,\n            }\n        ]\n        return samples\n\n    def setConceptProperty(self):\n        \"\"\"\n        set my concept property to any primary key or mandatory property\n        \"\"\"\n        self.conceptProperty = None\n        for prop in self.properties.values():\n            mandatory = False\n            primaryKey = False\n            if hasattr(prop, \"mandatory\"):\n                mandatory = prop.mandatory\n            if hasattr(prop, \"primaryKey\"):\n                primaryKey = prop.primaryKey\n            if mandatory or primaryKey:\n                self.conceptProperty = prop\n                break\n\n    @property\n    def pluralName(self):\n        \"\"\"\n        Getter for pluralName.\n\n        Returns:\n            str: The plural name of the topic.\n        \"\"\"\n        # Default behavior if _pluralName is not explicitly set\n        return self._pluralName if self._pluralName is not None else f\"{self.name}s\"\n\n    @pluralName.setter\n    def pluralName(self, value):\n        \"\"\"\n        Setter for pluralName.\n\n        Args:\n            value (str): The plural name to be set for the topic.\n        \"\"\"\n        self._pluralName = value\n\n    def getPluralName(self) -&gt; str:\n        \"\"\"\n        get the plural name for this topic\n\n        Returns:\n            str: the pluralname e.g. \"Topics\" for \"Topic\" or \"Status\" for \"Status\" or\n            \"Entities\" for \"Entity\"\n        \"\"\"\n        return self.pluralName\n\n    def getListLimit(self) -&gt; int:\n        \"\"\"\n        get the list limit for this topic\n        \"\"\"\n        listLimit = getattr(self, \"listLimit\", 200)\n        return listLimit\n\n    def sortProperties(self) -&gt; list:\n        \"\"\"\n        get the properties that we should sort by\n\n        Returns:\n            list: a list of properties in sort order\n        \"\"\"\n        prop_list = []\n        for prop in self.properties.values():\n            if hasattr(prop, \"sortPos\"):\n                sortPos = prop.sortPos\n                if sortPos:\n                    prop_list.append(prop)\n        prop_list = sorted(prop_list, key=lambda prop: prop.sortPos)\n        return prop_list\n\n    def propertiesByIndex(self) -&gt; list:\n        \"\"\"\n        return the properties by index\n\n        Returns:\n            list: the list of properties sorted by index\n        \"\"\"\n\n        def index(prop: \"Property\") -&gt; int:\n            if hasattr(prop, \"index\"):\n                return int(prop.index)\n            else:\n                return sys.maxsize\n\n        prop_list = sorted(self.properties.values(), key=lambda prop: index(prop))\n        return prop_list\n\n    def askSort(self) -&gt; str:\n        \"\"\"\n        generate the sort clause for my SMW ask query\n\n        Returns:\n            str: the generated wiki markup\n        \"\"\"\n        sort = \"\"\n        order = \"\"\n        delim = \"\"\n        sortproperties = self.sortProperties()\n        for prop in sortproperties:\n            direction = (\n                \"ascending\" if getattr(prop, \"sortAscending\", True) else \"descending\"\n            )\n            sort += delim + f\"{self.name} {prop.name}\"\n            order += delim + direction\n            delim = \",\"\n            pass\n        sortClause = f\"|sort={sort}\\n\" if sort else \"\"\n        orderClause = f\"|order={order}\\n\" if order else \"\"\n        markup = f\"{sortClause}{orderClause}\"\n        return markup\n\n    def askQuery(\n        self,\n        mainlabel: str = None,\n        filterShowInGrid: bool = True,\n        listLimit: int = None,\n    ) -&gt; str:\n        \"\"\"\n        get the askQuery for the me topic\n\n        Args:\n            mainlabel(str): the mainlabel to use - topic.name as default\n            filterShowInGrid(bool): if True include only properties with showInGrid not being false\n            listLimit(int): the list limit to use\n        Returns:\n            str: the markup for the query\n        \"\"\"\n        if listLimit is None:\n            listLimit = self.getListLimit()\n        if mainlabel is None:\n            mainlabel = self.name\n        markup = f\"\"\"{{{{#ask: [[Concept:{self.name}]]\n|mainlabel={mainlabel}\n\"\"\"\n        for prop in self.properties.values():\n            if filterShowInGrid and hasattr(prop, \"showInGrid\"):\n                show = prop.showInGrid\n            else:\n                show = True\n            if show:\n                markup += f\"|?{self.name} {prop.name} = {prop.name}\\n\"\n        markup += f\"|limit={listLimit}\\n\"\n        markup += f\"\"\"{self.askSort()}}}}}\"\"\"\n        return markup\n</code></pre>"},{"location":"#meta.metamodel.Topic.pluralName","title":"<code>pluralName</code>  <code>property</code> <code>writable</code>","text":"<p>Getter for pluralName.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The plural name of the topic.</p>"},{"location":"#meta.metamodel.Topic.__init__","title":"<code>__init__()</code>","text":"<p>constructor</p> Source code in <code>meta/metamodel.py</code> <pre><code>def __init__(self):\n    \"\"\"\n    constructor\n    \"\"\"\n    MetaModelElement.__init__(self)\n    self._pluralName = (\n        None  # Initialize with underscore to indicate a protected attribute\n    )\n\n    self.properties = {}\n    self.sourceTopicLinks = {}\n    self.targetTopicLinks = {}\n</code></pre>"},{"location":"#meta.metamodel.Topic.askQuery","title":"<code>askQuery(mainlabel=None, filterShowInGrid=True, listLimit=None)</code>","text":"<p>get the askQuery for the me topic</p> <p>Parameters:</p> Name Type Description Default <code>mainlabel(str)</code> <p>the mainlabel to use - topic.name as default</p> required <code>filterShowInGrid(bool)</code> <p>if True include only properties with showInGrid not being false</p> required <code>listLimit(int)</code> <p>the list limit to use</p> required <p>Returns:     str: the markup for the query</p> Source code in <code>meta/metamodel.py</code> <pre><code>    def askQuery(\n        self,\n        mainlabel: str = None,\n        filterShowInGrid: bool = True,\n        listLimit: int = None,\n    ) -&gt; str:\n        \"\"\"\n        get the askQuery for the me topic\n\n        Args:\n            mainlabel(str): the mainlabel to use - topic.name as default\n            filterShowInGrid(bool): if True include only properties with showInGrid not being false\n            listLimit(int): the list limit to use\n        Returns:\n            str: the markup for the query\n        \"\"\"\n        if listLimit is None:\n            listLimit = self.getListLimit()\n        if mainlabel is None:\n            mainlabel = self.name\n        markup = f\"\"\"{{{{#ask: [[Concept:{self.name}]]\n|mainlabel={mainlabel}\n\"\"\"\n        for prop in self.properties.values():\n            if filterShowInGrid and hasattr(prop, \"showInGrid\"):\n                show = prop.showInGrid\n            else:\n                show = True\n            if show:\n                markup += f\"|?{self.name} {prop.name} = {prop.name}\\n\"\n        markup += f\"|limit={listLimit}\\n\"\n        markup += f\"\"\"{self.askSort()}}}}}\"\"\"\n        return markup\n</code></pre>"},{"location":"#meta.metamodel.Topic.askSort","title":"<code>askSort()</code>","text":"<p>generate the sort clause for my SMW ask query</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the generated wiki markup</p> Source code in <code>meta/metamodel.py</code> <pre><code>def askSort(self) -&gt; str:\n    \"\"\"\n    generate the sort clause for my SMW ask query\n\n    Returns:\n        str: the generated wiki markup\n    \"\"\"\n    sort = \"\"\n    order = \"\"\n    delim = \"\"\n    sortproperties = self.sortProperties()\n    for prop in sortproperties:\n        direction = (\n            \"ascending\" if getattr(prop, \"sortAscending\", True) else \"descending\"\n        )\n        sort += delim + f\"{self.name} {prop.name}\"\n        order += delim + direction\n        delim = \",\"\n        pass\n    sortClause = f\"|sort={sort}\\n\" if sort else \"\"\n    orderClause = f\"|order={order}\\n\" if order else \"\"\n    markup = f\"{sortClause}{orderClause}\"\n    return markup\n</code></pre>"},{"location":"#meta.metamodel.Topic.getListLimit","title":"<code>getListLimit()</code>","text":"<p>get the list limit for this topic</p> Source code in <code>meta/metamodel.py</code> <pre><code>def getListLimit(self) -&gt; int:\n    \"\"\"\n    get the list limit for this topic\n    \"\"\"\n    listLimit = getattr(self, \"listLimit\", 200)\n    return listLimit\n</code></pre>"},{"location":"#meta.metamodel.Topic.getPluralName","title":"<code>getPluralName()</code>","text":"<p>get the plural name for this topic</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the pluralname e.g. \"Topics\" for \"Topic\" or \"Status\" for \"Status\" or</p> <code>str</code> <p>\"Entities\" for \"Entity\"</p> Source code in <code>meta/metamodel.py</code> <pre><code>def getPluralName(self) -&gt; str:\n    \"\"\"\n    get the plural name for this topic\n\n    Returns:\n        str: the pluralname e.g. \"Topics\" for \"Topic\" or \"Status\" for \"Status\" or\n        \"Entities\" for \"Entity\"\n    \"\"\"\n    return self.pluralName\n</code></pre>"},{"location":"#meta.metamodel.Topic.propertiesByIndex","title":"<code>propertiesByIndex()</code>","text":"<p>return the properties by index</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>the list of properties sorted by index</p> Source code in <code>meta/metamodel.py</code> <pre><code>def propertiesByIndex(self) -&gt; list:\n    \"\"\"\n    return the properties by index\n\n    Returns:\n        list: the list of properties sorted by index\n    \"\"\"\n\n    def index(prop: \"Property\") -&gt; int:\n        if hasattr(prop, \"index\"):\n            return int(prop.index)\n        else:\n            return sys.maxsize\n\n    prop_list = sorted(self.properties.values(), key=lambda prop: index(prop))\n    return prop_list\n</code></pre>"},{"location":"#meta.metamodel.Topic.setConceptProperty","title":"<code>setConceptProperty()</code>","text":"<p>set my concept property to any primary key or mandatory property</p> Source code in <code>meta/metamodel.py</code> <pre><code>def setConceptProperty(self):\n    \"\"\"\n    set my concept property to any primary key or mandatory property\n    \"\"\"\n    self.conceptProperty = None\n    for prop in self.properties.values():\n        mandatory = False\n        primaryKey = False\n        if hasattr(prop, \"mandatory\"):\n            mandatory = prop.mandatory\n        if hasattr(prop, \"primaryKey\"):\n            primaryKey = prop.primaryKey\n        if mandatory or primaryKey:\n            self.conceptProperty = prop\n            break\n</code></pre>"},{"location":"#meta.metamodel.Topic.sortProperties","title":"<code>sortProperties()</code>","text":"<p>get the properties that we should sort by</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>a list of properties in sort order</p> Source code in <code>meta/metamodel.py</code> <pre><code>def sortProperties(self) -&gt; list:\n    \"\"\"\n    get the properties that we should sort by\n\n    Returns:\n        list: a list of properties in sort order\n    \"\"\"\n    prop_list = []\n    for prop in self.properties.values():\n        if hasattr(prop, \"sortPos\"):\n            sortPos = prop.sortPos\n            if sortPos:\n                prop_list.append(prop)\n    prop_list = sorted(prop_list, key=lambda prop: prop.sortPos)\n    return prop_list\n</code></pre>"},{"location":"#meta.metamodel.TopicLink","title":"<code>TopicLink</code>","text":"<p>               Bases: <code>MetaModelElement</code></p> <p>A TopicLink links two Concepts/Topics</p> Source code in <code>meta/metamodel.py</code> <pre><code>class TopicLink(MetaModelElement):\n    \"\"\"\n    A TopicLink links two Concepts/Topics\n    \"\"\"\n\n    @classmethod\n    def getSamples(cls):\n        samples = [\n            {\n                \"isA\": \"TopicLink\",\n                \"name\": \"containedProperties\",\n                \"sourceRole\": \"topic\",\n                \"sourceMultiple\": False,\n                \"source\": \"Topic\",\n                \"targetRole\": \"properties\",\n                \"targetMultiple\": True,\n                \"target\": \"Property\",\n            },\n            {\n                \"isA\": \"TopicLink\",\n                \"name\": \"containedTopics\",\n                \"sourceRole\": \"context\",\n                \"sourceMultiple\": False,\n                \"source\": \"Context\",\n                \"targetRole\": \"topics\",\n                \"targetMultiple\": True,\n                \"target\": \"Topic\",\n            },\n            {\n                \"isA\": \"TopicLink\",\n                \"name\": \"typeOfProperty\",\n                \"sourceRole\": \"usedByProperties\",\n                \"sourceMultiple\": True,\n                \"source\": \"Property\",\n                \"sourceDocumentation\": \"the properties having this type\",\n                \"targetRole\": \"smw_type\",\n                \"targetMultiple\": False,\n                \"target\": \"SMW_Type\",\n                \"masterDetail\": False,\n                \"targetDocumentation\": \"the smw_type being used by this property\",\n            },\n        ]\n        return samples\n</code></pre>"},{"location":"#meta.metamodel_cmd","title":"<code>metamodel_cmd</code>","text":"<p>Created on 2023-02-19</p> <p>@author: wf</p>"},{"location":"#meta.metamodel_cmd.MetaModelCmd","title":"<code>MetaModelCmd</code>","text":"<p>command line interface for metamodel handling</p> Source code in <code>meta/metamodel_cmd.py</code> <pre><code>class MetaModelCmd:\n    \"\"\"\n    command line interface for metamodel handling\n    \"\"\"\n\n    def __init__(self, debug: bool = False):\n        \"\"\"\n        constructor\n\n        Args:\n            debug(bool): if True switch debugging on\n        \"\"\"\n        self.debug = debug\n        self.error = None\n        self.errMsg = None\n        self.context = None\n\n    @classmethod\n    def getArgParser(cls):\n        \"\"\"\n        get my argument parser\n        \"\"\"\n        program_shortdesc = Version.description\n        program_license = \"\"\"%s\n\n          Created by %s on %s.\n          Copyright 2022-2024 Wolfgang Fahl. All rights reserved.\n\n          Licensed under the Apache License 2.0\n          http://www.apache.org/licenses/LICENSE-2.0\n\n          Distributed on an \"AS IS\" basis without warranties\n          or conditions of any kind, either express or implied.\n\n        USAGE\n        \"\"\" % (\n            program_shortdesc,\n            Version.authors,\n            str(__date__),\n        )\n        parser = ArgumentParser(\n            description=program_license, formatter_class=RawDescriptionHelpFormatter\n        )\n        parser.add_argument(\n            \"--about\",\n            help=\"show about info [default: %(default)s]\",\n            action=\"store_true\",\n        )\n        parser.add_argument(\n            \"--context\",\n            default=\"MetaModel\",\n            help=\"context to read [default: %(default)s]\",\n        )\n        parser.add_argument(\"--copyright\", help=\"copyright message for diagrams\")\n        parser.add_argument(\n            \"-d\", \"--debug\", dest=\"debug\", action=\"store_true\", help=\"show debug info\"\n        )\n        parser.add_argument(\n            \"-wd\",\n            \"--doc_width\",\n            help=\"Maximum width of documentation (default: %(default)s)\",\n            type=int,\n            default=40,\n        )\n        parser.add_argument(\"-i\", \"--input\", help=\"input file\")\n\n        parser.add_argument(\n            \"-l\", \"--linkml\", action=\"store_true\", help=\"create linkml yaml file\"\n        )\n        parser.add_argument(\"-t\", \"--title\", help=\"the title of a diagram\")\n        parser.add_argument(\n            \"-u\", \"--uml\", action=\"store_true\", help=\"create plantuml diagram\"\n        )\n        parser.add_argument(\n            \"-at\",\n            \"--withAt\",\n            action=\"store_true\",\n            help=\"generate with @startuml/@enduml bracket\",\n        )\n        parser.add_argument(\n            \"--wikiId\",\n            default=\"wiki\",\n            help=\"id of the wiki to generate for [default: %(default)s]\",\n        )\n        return parser\n\n    def readContext(self, args):\n        \"\"\"\n        read the context from the given args\n\n        Args:\n            args(Args): command line arguments\n        \"\"\"\n        if args.input:\n            result_tuple = Context.fromSiDIF_input(args.input, debug=args.debug)\n            self.context, self.error, self.errMsg = result_tuple\n        elif args.wikiId and args.context:\n            self.wikiId = args.wikiId\n            self.smwAccess = SMWAccess(args.wikiId)\n            self.mw_contexts = self.smwAccess.getMwContexts()\n            self.mw_context = self.mw_contexts.get(args.context, None)\n            self.context, self.error, self.errMsg = Context.fromWikiContext(\n                self.mw_context, debug=args.debug\n            )\n\n    def hasError(self):\n        if self.error is not None:\n            print(f\"reading Context failed:\\n{self.errMsg}\\n{self.error}\")\n        return self.error\n\n    def genUml(self, args) -&gt; str:\n        \"\"\"\n        generate uml for the given context with the given name from the given wiki\n\n        Args:\n           args: the command line arguments\n\n        Returns:\n            str: the PlantUml\n        \"\"\"\n        self.readContext(args)\n        uml=None\n        if not self.hasError():\n            uml = PlantUml(\n                title=args.title,\n                copyRight=args.copyright,\n                withAt=args.withAt,\n                doc_width=args.doc_width,\n            )\n            uml.fromDIF(self.context.dif)\n        return uml\n\n\n    def genLinkML(self, args) -&gt; str:\n        \"\"\"\n        generate linkML yaml for the given command line arguments\n\n        Args:\n           args: the command line arguments\n\n        Returns:\n            str: the uml markup\n        \"\"\"\n        self.readContext(args)\n        if not self.hasError():\n            sidif2LinkML = SiDIF2LinkML(self.context)\n            yaml_text = sidif2LinkML.asYaml()\n            return yaml_text\n        else:\n            return None\n</code></pre>"},{"location":"#meta.metamodel_cmd.MetaModelCmd.__init__","title":"<code>__init__(debug=False)</code>","text":"<p>constructor</p> <p>Parameters:</p> Name Type Description Default <code>debug(bool)</code> <p>if True switch debugging on</p> required Source code in <code>meta/metamodel_cmd.py</code> <pre><code>def __init__(self, debug: bool = False):\n    \"\"\"\n    constructor\n\n    Args:\n        debug(bool): if True switch debugging on\n    \"\"\"\n    self.debug = debug\n    self.error = None\n    self.errMsg = None\n    self.context = None\n</code></pre>"},{"location":"#meta.metamodel_cmd.MetaModelCmd.genLinkML","title":"<code>genLinkML(args)</code>","text":"<p>generate linkML yaml for the given command line arguments</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>the command line arguments</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the uml markup</p> Source code in <code>meta/metamodel_cmd.py</code> <pre><code>def genLinkML(self, args) -&gt; str:\n    \"\"\"\n    generate linkML yaml for the given command line arguments\n\n    Args:\n       args: the command line arguments\n\n    Returns:\n        str: the uml markup\n    \"\"\"\n    self.readContext(args)\n    if not self.hasError():\n        sidif2LinkML = SiDIF2LinkML(self.context)\n        yaml_text = sidif2LinkML.asYaml()\n        return yaml_text\n    else:\n        return None\n</code></pre>"},{"location":"#meta.metamodel_cmd.MetaModelCmd.genUml","title":"<code>genUml(args)</code>","text":"<p>generate uml for the given context with the given name from the given wiki</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <p>the command line arguments</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the PlantUml</p> Source code in <code>meta/metamodel_cmd.py</code> <pre><code>def genUml(self, args) -&gt; str:\n    \"\"\"\n    generate uml for the given context with the given name from the given wiki\n\n    Args:\n       args: the command line arguments\n\n    Returns:\n        str: the PlantUml\n    \"\"\"\n    self.readContext(args)\n    uml=None\n    if not self.hasError():\n        uml = PlantUml(\n            title=args.title,\n            copyRight=args.copyright,\n            withAt=args.withAt,\n            doc_width=args.doc_width,\n        )\n        uml.fromDIF(self.context.dif)\n    return uml\n</code></pre>"},{"location":"#meta.metamodel_cmd.MetaModelCmd.getArgParser","title":"<code>getArgParser()</code>  <code>classmethod</code>","text":"<p>get my argument parser</p> Source code in <code>meta/metamodel_cmd.py</code> <pre><code>@classmethod\ndef getArgParser(cls):\n    \"\"\"\n    get my argument parser\n    \"\"\"\n    program_shortdesc = Version.description\n    program_license = \"\"\"%s\n\n      Created by %s on %s.\n      Copyright 2022-2024 Wolfgang Fahl. All rights reserved.\n\n      Licensed under the Apache License 2.0\n      http://www.apache.org/licenses/LICENSE-2.0\n\n      Distributed on an \"AS IS\" basis without warranties\n      or conditions of any kind, either express or implied.\n\n    USAGE\n    \"\"\" % (\n        program_shortdesc,\n        Version.authors,\n        str(__date__),\n    )\n    parser = ArgumentParser(\n        description=program_license, formatter_class=RawDescriptionHelpFormatter\n    )\n    parser.add_argument(\n        \"--about\",\n        help=\"show about info [default: %(default)s]\",\n        action=\"store_true\",\n    )\n    parser.add_argument(\n        \"--context\",\n        default=\"MetaModel\",\n        help=\"context to read [default: %(default)s]\",\n    )\n    parser.add_argument(\"--copyright\", help=\"copyright message for diagrams\")\n    parser.add_argument(\n        \"-d\", \"--debug\", dest=\"debug\", action=\"store_true\", help=\"show debug info\"\n    )\n    parser.add_argument(\n        \"-wd\",\n        \"--doc_width\",\n        help=\"Maximum width of documentation (default: %(default)s)\",\n        type=int,\n        default=40,\n    )\n    parser.add_argument(\"-i\", \"--input\", help=\"input file\")\n\n    parser.add_argument(\n        \"-l\", \"--linkml\", action=\"store_true\", help=\"create linkml yaml file\"\n    )\n    parser.add_argument(\"-t\", \"--title\", help=\"the title of a diagram\")\n    parser.add_argument(\n        \"-u\", \"--uml\", action=\"store_true\", help=\"create plantuml diagram\"\n    )\n    parser.add_argument(\n        \"-at\",\n        \"--withAt\",\n        action=\"store_true\",\n        help=\"generate with @startuml/@enduml bracket\",\n    )\n    parser.add_argument(\n        \"--wikiId\",\n        default=\"wiki\",\n        help=\"id of the wiki to generate for [default: %(default)s]\",\n    )\n    return parser\n</code></pre>"},{"location":"#meta.metamodel_cmd.MetaModelCmd.readContext","title":"<code>readContext(args)</code>","text":"<p>read the context from the given args</p> <p>Parameters:</p> Name Type Description Default <code>args(Args)</code> <p>command line arguments</p> required Source code in <code>meta/metamodel_cmd.py</code> <pre><code>def readContext(self, args):\n    \"\"\"\n    read the context from the given args\n\n    Args:\n        args(Args): command line arguments\n    \"\"\"\n    if args.input:\n        result_tuple = Context.fromSiDIF_input(args.input, debug=args.debug)\n        self.context, self.error, self.errMsg = result_tuple\n    elif args.wikiId and args.context:\n        self.wikiId = args.wikiId\n        self.smwAccess = SMWAccess(args.wikiId)\n        self.mw_contexts = self.smwAccess.getMwContexts()\n        self.mw_context = self.mw_contexts.get(args.context, None)\n        self.context, self.error, self.errMsg = Context.fromWikiContext(\n            self.mw_context, debug=args.debug\n        )\n</code></pre>"},{"location":"#meta.metamodel_cmd.main","title":"<code>main(argv=None)</code>","text":"<p>main program.</p> Source code in <code>meta/metamodel_cmd.py</code> <pre><code>def main(argv=None):  # IGNORE:C0111\n    \"\"\"main program.\"\"\"\n\n    if argv is None:\n        argv = sys.argv[1:]\n\n    program_name = os.path.basename(__file__)\n    program_version = f\"v{__version__}\"\n    program_build_date = str(__updated__)\n    program_version_message = f\"{program_name} ({program_version},{program_build_date})\"\n\n    try:\n        parser = MetaModelCmd.getArgParser()\n        # Setup argument parser\n        if len(argv) &lt; 1:\n            parser.print_usage()\n            sys.exit(1)\n\n        args = parser.parse_args(argv)\n        mm_cmd = MetaModelCmd(debug=args.debug)\n        if args.about:\n            print(program_version_message)\n            print(f\"see {Version.doc_url}\")\n            webbrowser.open(Version.doc_url)\n        if args.uml:\n            uml = mm_cmd.genUml(args)\n            print(uml)\n        elif args.linkml:\n            mm_cmd = MetaModelCmd(debug=args.debug)\n            linkml_yaml = mm_cmd.genLinkML(args)\n            print(linkml_yaml)\n\n    except KeyboardInterrupt:\n        ### handle keyboard interrupt ###\n        return 1\n    except Exception as e:\n        if DEBUG:\n            raise (e)\n        indent = len(program_name) * \" \"\n        sys.stderr.write(program_name + \": \" + repr(e) + \"\\n\")\n        sys.stderr.write(indent + \"  for help use --help\")\n        if args.debug:\n            print(traceback.format_exc())\n        return 2\n</code></pre>"},{"location":"#meta.mw","title":"<code>mw</code>","text":"<p>Created on 23.11.2022</p> <p>@author: wf</p>"},{"location":"#meta.mw.MediaWikiContext","title":"<code>MediaWikiContext</code>  <code>dataclass</code>","text":"<p>Class for keeping track of MediaWiki Context</p> Source code in <code>meta/mw.py</code> <pre><code>@dataclass\nclass MediaWikiContext:\n    \"\"\"Class for keeping track of MediaWiki Context\"\"\"\n\n    wikiId: str\n    wiki_url: str\n    context: str\n    since: datetime.datetime\n    master: str\n\n    def sidif_url(self):\n        \"\"\"\n        return the sidif url\n        \"\"\"\n        url = f\"{self.wiki_url}/index.php/{self.context}#sidif\"\n        return url\n\n    def read_sidif(self) -&gt; str:\n        \"\"\"\n\n        Read the SiDIF for this Mediawiki context\n\n        Args:\n            withLogin(bool): if True login\n\n        Returns:\n            str: the SiDIF\n        \"\"\"\n        sidif = None\n        wikiusers = WikiUser.getWikiUsers(lenient=True)\n        if self.wikiId in wikiusers:\n            wikiUser = wikiusers[self.wikiId]\n            self.wikiClient = WikiClient.ofWikiId(wikiUser.wikiId)\n            if self.wikiClient.needsLogin():\n                self.wikiClient.login()\n            pageTitle = f\"{self.context}\"\n            page = self.wikiClient.getPage(pageTitle)\n            if page.exists:\n                markup = page.text()\n                mw_code = mwparserfromhell.parse(markup)\n                sidif_sections = mw_code.get_sections(matches=\"sidif\")\n                if len(sidif_sections) != 1:\n                    raise Exception(\n                        f\"found {len(sidif_sections)} sidif sections but expected exactly 1\"\n                    )\n                for node in sidif_sections[0].filter_tags(matches=\"source\"):\n                    sidif = str(node.contents)\n        return sidif\n</code></pre>"},{"location":"#meta.mw.MediaWikiContext.read_sidif","title":"<code>read_sidif()</code>","text":"<p>Read the SiDIF for this Mediawiki context</p> <p>Parameters:</p> Name Type Description Default <code>withLogin(bool)</code> <p>if True login</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the SiDIF</p> Source code in <code>meta/mw.py</code> <pre><code>def read_sidif(self) -&gt; str:\n    \"\"\"\n\n    Read the SiDIF for this Mediawiki context\n\n    Args:\n        withLogin(bool): if True login\n\n    Returns:\n        str: the SiDIF\n    \"\"\"\n    sidif = None\n    wikiusers = WikiUser.getWikiUsers(lenient=True)\n    if self.wikiId in wikiusers:\n        wikiUser = wikiusers[self.wikiId]\n        self.wikiClient = WikiClient.ofWikiId(wikiUser.wikiId)\n        if self.wikiClient.needsLogin():\n            self.wikiClient.login()\n        pageTitle = f\"{self.context}\"\n        page = self.wikiClient.getPage(pageTitle)\n        if page.exists:\n            markup = page.text()\n            mw_code = mwparserfromhell.parse(markup)\n            sidif_sections = mw_code.get_sections(matches=\"sidif\")\n            if len(sidif_sections) != 1:\n                raise Exception(\n                    f\"found {len(sidif_sections)} sidif sections but expected exactly 1\"\n                )\n            for node in sidif_sections[0].filter_tags(matches=\"source\"):\n                sidif = str(node.contents)\n    return sidif\n</code></pre>"},{"location":"#meta.mw.MediaWikiContext.sidif_url","title":"<code>sidif_url()</code>","text":"<p>return the sidif url</p> Source code in <code>meta/mw.py</code> <pre><code>def sidif_url(self):\n    \"\"\"\n    return the sidif url\n    \"\"\"\n    url = f\"{self.wiki_url}/index.php/{self.context}#sidif\"\n    return url\n</code></pre>"},{"location":"#meta.mw.SMWAccess","title":"<code>SMWAccess</code>","text":"<p>access to semantic MediaWiki</p> Source code in <code>meta/mw.py</code> <pre><code>class SMWAccess:\n    \"\"\"\n    access to semantic MediaWiki\n    \"\"\"\n\n    def __init__(self, wikiId: str = \"wiki\", debug: bool = False):\n        \"\"\"\n        constructor\n        \"\"\"\n        self.wikiId = wikiId\n        self.smw = self.getSMW(wikiId)\n        self.debug = debug\n        self.url = f\"{self.wikiClient.wikiUser.getWikiUrl()}\"\n\n    def getSMW(self, wikiId: str):\n        \"\"\"\n        get the semantic mediawiki access\n        \"\"\"\n        self.wikiClient = WikiClient.ofWikiId(wikiId)\n        if self.wikiClient.needsLogin():\n            self.wikiClient.login()\n        smw = SMWClient(self.wikiClient.getSite())\n        return smw\n\n    def getMwContexts(self):\n        \"\"\"\n        get the contexts\n        \"\"\"\n        ask = \"\"\"{{#ask: [[Concept:Context]]\n|mainlabel=Context\n| ?Context name = name\n| ?Context since = since\n| ?Context master = master\n\n|sort=Context name\n|order=ascending\n}}\"\"\"\n        mw_contexts = {}\n        context_records = self.smw.query(ask, \"list of contexts\")\n        for context_name, context_record in context_records.items():\n            if self.debug:\n                print(context_record)\n            mw_contexts[context_name] = MediaWikiContext(\n                self.wikiId,\n                self.url,\n                context_name,\n                context_record[\"since\"],\n                context_record[\"master\"],\n            )\n        return mw_contexts\n</code></pre>"},{"location":"#meta.mw.SMWAccess.__init__","title":"<code>__init__(wikiId='wiki', debug=False)</code>","text":"<p>constructor</p> Source code in <code>meta/mw.py</code> <pre><code>def __init__(self, wikiId: str = \"wiki\", debug: bool = False):\n    \"\"\"\n    constructor\n    \"\"\"\n    self.wikiId = wikiId\n    self.smw = self.getSMW(wikiId)\n    self.debug = debug\n    self.url = f\"{self.wikiClient.wikiUser.getWikiUrl()}\"\n</code></pre>"},{"location":"#meta.mw.SMWAccess.getMwContexts","title":"<code>getMwContexts()</code>","text":"<p>get the contexts</p> Source code in <code>meta/mw.py</code> <pre><code>    def getMwContexts(self):\n        \"\"\"\n        get the contexts\n        \"\"\"\n        ask = \"\"\"{{#ask: [[Concept:Context]]\n|mainlabel=Context\n| ?Context name = name\n| ?Context since = since\n| ?Context master = master\n\n|sort=Context name\n|order=ascending\n}}\"\"\"\n        mw_contexts = {}\n        context_records = self.smw.query(ask, \"list of contexts\")\n        for context_name, context_record in context_records.items():\n            if self.debug:\n                print(context_record)\n            mw_contexts[context_name] = MediaWikiContext(\n                self.wikiId,\n                self.url,\n                context_name,\n                context_record[\"since\"],\n                context_record[\"master\"],\n            )\n        return mw_contexts\n</code></pre>"},{"location":"#meta.mw.SMWAccess.getSMW","title":"<code>getSMW(wikiId)</code>","text":"<p>get the semantic mediawiki access</p> Source code in <code>meta/mw.py</code> <pre><code>def getSMW(self, wikiId: str):\n    \"\"\"\n    get the semantic mediawiki access\n    \"\"\"\n    self.wikiClient = WikiClient.ofWikiId(wikiId)\n    if self.wikiClient.needsLogin():\n        self.wikiClient.login()\n    smw = SMWClient(self.wikiClient.getSite())\n    return smw\n</code></pre>"},{"location":"#meta.profiler","title":"<code>profiler</code>","text":"<p>Created on 2022-11-18</p> <p>@author: wf</p>"},{"location":"#meta.profiler.Profiler","title":"<code>Profiler</code>","text":"<p>simple profiler</p> Source code in <code>meta/profiler.py</code> <pre><code>class Profiler:\n    \"\"\"\n    simple profiler\n    \"\"\"\n\n    def __init__(self, msg, profile=True):\n        \"\"\"\n        construct me with the given msg and profile active flag\n\n        Args:\n            msg(str): the message to show if profiling is active\n            profile(bool): True if messages should be shown\n        \"\"\"\n        self.msg = msg\n        self.profile = profile\n        self.starttime = time.time()\n        if profile:\n            print(f\"Starting {msg} ...\")\n\n    def time(self, extraMsg=\"\"):\n        \"\"\"\n        time the action and print if profile is active\n        \"\"\"\n        elapsed = time.time() - self.starttime\n        if self.profile:\n            print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n        return elapsed\n</code></pre>"},{"location":"#meta.profiler.Profiler.__init__","title":"<code>__init__(msg, profile=True)</code>","text":"<p>construct me with the given msg and profile active flag</p> <p>Parameters:</p> Name Type Description Default <code>msg(str)</code> <p>the message to show if profiling is active</p> required <code>profile(bool)</code> <p>True if messages should be shown</p> required Source code in <code>meta/profiler.py</code> <pre><code>def __init__(self, msg, profile=True):\n    \"\"\"\n    construct me with the given msg and profile active flag\n\n    Args:\n        msg(str): the message to show if profiling is active\n        profile(bool): True if messages should be shown\n    \"\"\"\n    self.msg = msg\n    self.profile = profile\n    self.starttime = time.time()\n    if profile:\n        print(f\"Starting {msg} ...\")\n</code></pre>"},{"location":"#meta.profiler.Profiler.time","title":"<code>time(extraMsg='')</code>","text":"<p>time the action and print if profile is active</p> Source code in <code>meta/profiler.py</code> <pre><code>def time(self, extraMsg=\"\"):\n    \"\"\"\n    time the action and print if profile is active\n    \"\"\"\n    elapsed = time.time() - self.starttime\n    if self.profile:\n        print(f\"{self.msg}{extraMsg} took {elapsed:5.1f} s\")\n    return elapsed\n</code></pre>"},{"location":"#meta.sidif2linkml","title":"<code>sidif2linkml</code>","text":"<p>Created on 2023-02-20</p> <p>@author: wf</p>"},{"location":"#meta.sidif2linkml.SiDIF2LinkML","title":"<code>SiDIF2LinkML</code>","text":"<p>converter between SiDIF and LINKML</p> Source code in <code>meta/sidif2linkml.py</code> <pre><code>class SiDIF2LinkML:\n    \"\"\"\n    converter between SiDIF and LINKML\n    \"\"\"\n\n    def __init__(self, context: Context):\n        self.context = context\n\n    def asYaml(self, common_property_slots: bool = True, delim=\"_\") -&gt; str:\n        \"\"\"\n        convert my context\n\n        Args:\n            common_property_slots(bool): if True reuse slots\n\n        Returns:\n            str: the yaml markup\n\n        \"\"\"\n        context = self.context\n        sb = SchemaBuilder(id=context.name, name=context.name)\n        # https://linkml.io/linkml-model/docs/SchemaDefinition/\n        sb.add_defaults()\n        sd = sb.schema\n        sv = SchemaView(sd)\n        if hasattr(context, \"copyright\"):\n            copyright_str = f\" copyright {context.copyright}\"\n        else:\n            copyright_str = \"\"\n        if hasattr(context, \"master\"):\n            master = context.master\n        else:\n            master = \"http://example.com\"\n        uri = f\"{master}/{context.name}\"\n        for topic in self.context.topics.values():\n            cd = ClassDefinition(name=topic.name)\n            cd.description = topic.documentation\n            sv.add_class(cd)\n            for prop in topic.properties.values():\n                slot = None\n                if common_property_slots:\n                    qname = prop.name\n                    if prop.name in sd.slots:\n                        slot = sd.slots[prop.name]\n                        slot.description += \",\" + prop.documentation\n                else:\n                    qname = f\"{topic.name}{delim}{prop.name}\"\n                if slot is None:\n                    slot = SlotDefinition(name=qname)\n                    if hasattr(prop, \"documentation\"):\n                        slot.description = prop.documentation\n                    typesMap = {\n                        \"Boolean\": \"boolean\",\n                        \"Code\": \"string\",  # @TODO will need special type\n                        \"Date\": \"date\",\n                        \"Text\": \"string\",\n                        \"URL\": \"uri\",\n                        \"Page\": \"string\",  # @TODO will need own type\n                        \"Number\": \"double\",  # @TODO will need special type handling\n                    }\n                    if prop.isLink:\n                        # 1:1 and 1:n handling\n                        slot.range = prop.topicLink.source\n                    else:\n                        if prop.type in typesMap:\n                            slot.range = typesMap[prop.type]\n                        else:\n                            slot.range = \"string\"\n                    sv.add_slot(slot)\n                cd.attributes[qname] = slot\n                pass\n\n            pass\n\n        lml_gen = LinkmlGenerator(schema=sd, format=\"yaml\")\n        yaml_text = lml_gen.serialize()\n        return yaml_text\n</code></pre>"},{"location":"#meta.sidif2linkml.SiDIF2LinkML.asYaml","title":"<code>asYaml(common_property_slots=True, delim='_')</code>","text":"<p>convert my context</p> <p>Parameters:</p> Name Type Description Default <code>common_property_slots(bool)</code> <p>if True reuse slots</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the yaml markup</p> Source code in <code>meta/sidif2linkml.py</code> <pre><code>def asYaml(self, common_property_slots: bool = True, delim=\"_\") -&gt; str:\n    \"\"\"\n    convert my context\n\n    Args:\n        common_property_slots(bool): if True reuse slots\n\n    Returns:\n        str: the yaml markup\n\n    \"\"\"\n    context = self.context\n    sb = SchemaBuilder(id=context.name, name=context.name)\n    # https://linkml.io/linkml-model/docs/SchemaDefinition/\n    sb.add_defaults()\n    sd = sb.schema\n    sv = SchemaView(sd)\n    if hasattr(context, \"copyright\"):\n        copyright_str = f\" copyright {context.copyright}\"\n    else:\n        copyright_str = \"\"\n    if hasattr(context, \"master\"):\n        master = context.master\n    else:\n        master = \"http://example.com\"\n    uri = f\"{master}/{context.name}\"\n    for topic in self.context.topics.values():\n        cd = ClassDefinition(name=topic.name)\n        cd.description = topic.documentation\n        sv.add_class(cd)\n        for prop in topic.properties.values():\n            slot = None\n            if common_property_slots:\n                qname = prop.name\n                if prop.name in sd.slots:\n                    slot = sd.slots[prop.name]\n                    slot.description += \",\" + prop.documentation\n            else:\n                qname = f\"{topic.name}{delim}{prop.name}\"\n            if slot is None:\n                slot = SlotDefinition(name=qname)\n                if hasattr(prop, \"documentation\"):\n                    slot.description = prop.documentation\n                typesMap = {\n                    \"Boolean\": \"boolean\",\n                    \"Code\": \"string\",  # @TODO will need special type\n                    \"Date\": \"date\",\n                    \"Text\": \"string\",\n                    \"URL\": \"uri\",\n                    \"Page\": \"string\",  # @TODO will need own type\n                    \"Number\": \"double\",  # @TODO will need special type handling\n                }\n                if prop.isLink:\n                    # 1:1 and 1:n handling\n                    slot.range = prop.topicLink.source\n                else:\n                    if prop.type in typesMap:\n                        slot.range = typesMap[prop.type]\n                    else:\n                        slot.range = \"string\"\n                sv.add_slot(slot)\n            cd.attributes[qname] = slot\n            pass\n\n        pass\n\n    lml_gen = LinkmlGenerator(schema=sd, format=\"yaml\")\n    yaml_text = lml_gen.serialize()\n    return yaml_text\n</code></pre>"},{"location":"#meta.smw_type","title":"<code>smw_type</code>","text":""},{"location":"#meta.smw_type.SMW_Type","title":"<code>SMW_Type</code>  <code>dataclass</code>","text":"<p>an SMW_Type is a data type which determines the possible values for that type e.g. a Boolean can hold true/false values while a Number can hold 3.1459 or 20. A Page can hold the name of a Wiki page see https://semantic-mediawiki.org/wiki/Help:List_of_datatypes</p> Source code in <code>meta/smw_type.py</code> <pre><code>@dataclass\nclass SMW_Type:\n    \"\"\"\n    an SMW_Type is a data type which determines the possible values for that type e.g. a Boolean can hold true/false values while a Number can hold 3.1459 or 20. A Page can hold the name of a Wiki page see https://semantic-mediawiki.org/wiki/Help:List_of_datatypes\n    \"\"\"\n\n    pageTitle: str\n    type: Optional[\n        str\n    ]  # The Semantic MediaWiki type  without the prefix e.g. Text, Number, Boolean\n    documentation: Optional[str]  # The documentation of this Semantic Media Wiki type\n    id: Optional[str]  # SMW internal id of the type\n    helppage: Optional[str]  # The url of the 'official' documentation page of this type\n    typepage: Optional[\n        str\n    ]  # The Semantic Media Wiki Special page for this specific type e.g. Special:Types/Text, Special:Types/Boolean, Special:Types/Date, Special:Types/Number, Special:Types/Page\n    javaType: Optional[str]  # Java mapping of this type\n\n    @classmethod\n    def askQuery(cls):\n        \"\"\"\n        get the ask Query for SMW_Type\n\n        Returns:\n            str: the mediawiki markup for the ask query\n        \"\"\"\n        ask = \"\"\"{{#ask: [[Concept:SMW_Type]]\n|mainlabel=pageTitle\n|?SMW_Type type = type\n|?SMW_Type documentation = documentation\n|?SMW_Type id = id\n|?SMW_Type helppage = helppage\n|?SMW_Type typepage = typepage\n|?SMW_Type javaType = javaType\n| limit=200\n}}\"\"\"\n        return ask\n\n    @classmethod\n    def fromDict(cls, data: dict):\n        \"\"\"\n        create a SMW_Type from the given dict\n\n        Args:\n            data(dict): the dict to create the SMW_Type from\n\n        Returns:\n            SMW_Type: the freshly created SMW_Type\n        \"\"\"\n        smw_type = dacite.from_dict(data_class=cls, data=data)\n        return smw_type\n</code></pre>"},{"location":"#meta.smw_type.SMW_Type.askQuery","title":"<code>askQuery()</code>  <code>classmethod</code>","text":"<p>get the ask Query for SMW_Type</p> <p>Returns:</p> Name Type Description <code>str</code> <p>the mediawiki markup for the ask query</p> Source code in <code>meta/smw_type.py</code> <pre><code>    @classmethod\n    def askQuery(cls):\n        \"\"\"\n        get the ask Query for SMW_Type\n\n        Returns:\n            str: the mediawiki markup for the ask query\n        \"\"\"\n        ask = \"\"\"{{#ask: [[Concept:SMW_Type]]\n|mainlabel=pageTitle\n|?SMW_Type type = type\n|?SMW_Type documentation = documentation\n|?SMW_Type id = id\n|?SMW_Type helppage = helppage\n|?SMW_Type typepage = typepage\n|?SMW_Type javaType = javaType\n| limit=200\n}}\"\"\"\n        return ask\n</code></pre>"},{"location":"#meta.smw_type.SMW_Type.fromDict","title":"<code>fromDict(data)</code>  <code>classmethod</code>","text":"<p>create a SMW_Type from the given dict</p> <p>Parameters:</p> Name Type Description Default <code>data(dict)</code> <p>the dict to create the SMW_Type from</p> required <p>Returns:</p> Name Type Description <code>SMW_Type</code> <p>the freshly created SMW_Type</p> Source code in <code>meta/smw_type.py</code> <pre><code>@classmethod\ndef fromDict(cls, data: dict):\n    \"\"\"\n    create a SMW_Type from the given dict\n\n    Args:\n        data(dict): the dict to create the SMW_Type from\n\n    Returns:\n        SMW_Type: the freshly created SMW_Type\n    \"\"\"\n    smw_type = dacite.from_dict(data_class=cls, data=data)\n    return smw_type\n</code></pre>"},{"location":"#meta.uml","title":"<code>uml</code>","text":"<p>Created on 2020-11-12</p> <p>@author: wf</p>"},{"location":"#meta.uml.PlantUml","title":"<code>PlantUml</code>","text":"<p>               Bases: <code>object</code></p> <p>Plant UML support</p> Source code in <code>meta/uml.py</code> <pre><code>class PlantUml(object):\n    \"\"\"\n    Plant UML support\n    \"\"\"\n\n    # redundant to skinparams in pylodstorage.uml\n    skinparams = \"\"\"\n' BITPlan Corporate identity skin params\n' Copyright (c) 2015-2024 BITPlan GmbH\n' see http://wiki.bitplan.com/PlantUmlSkinParams#BITPlanCI\n' skinparams generated by com.bitplan.restmodelmanager\nskinparam note {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam component {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam package {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam usecase {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam activity {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam classAttribute {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam interface {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam class {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nskinparam object {\n  BackGroundColor #FFFFFF\n  FontSize 12\n  ArrowColor #FF8000\n  BorderColor #FF8000\n  FontColor black\n  FontName Technical\n}\nhide Circle\n' end of skinparams '\n\"\"\"\n\n    def __init__(\n        self,\n        copyRight=None,\n        title=None,\n        debug=False,\n        withSkin: bool = True,\n        withAt: bool = False,\n        doc_width: int = 40,\n    ):\n        \"\"\"\n        Constructor\n        \"\"\"\n        self.debug = debug\n        self.withSkin = withSkin\n        self.withAt = withAt\n        self.uml = \"\"\n        self.title = title\n        self.copyRight = copyRight\n        self.doc_width = doc_width\n\n    def __str__(self):\n        return self.atIt(self.uml)\n\n    def atIt(self, markup: str):\n        \"\"\"\n        Args:\n            markup(str): the markup\n        Returns:\n            str: markup with @startuml and @enduml\n        \"\"\"\n        if not self.withAt:\n            return markup\n        at_markup = f\"\"\"@startuml\n{markup}\n@enduml\"\"\"\n        return at_markup\n\n    def multi_line_doc(self, doc: str, width: int) -&gt; str:\n        \"\"\"\n        Returns the given documentation as a multiline string with a limited length per line.\n        Lines are broken at whitespace.\n\n        Args:\n            doc(str): the documentation to wrap\n            width(int): The maximum length of each line.\n        Returns:\n            str: the  Multiline string.\n        \"\"\"\n        text = \"\\n\".join(textwrap.wrap(doc, width=width))\n        return text\n\n    def asUmlDict(self, dif):\n        \"\"\"\n        return the given DataInterchange as an UML Dict\n        \"\"\"\n        uml = {\"packages\": {}, \"topiclinks\": {}}\n        classKey = None\n        classes = {}\n        for _i, triple in enumerate(dif.triples):\n            if self.debug:\n                print(triple)\n            if triple.p == \"isA\":\n                itkey = triple.s\n                if triple.o == \"Context\":\n                    packageKey = itkey\n                    packages = uml[\"packages\"]\n                    packages[itkey] = {\"classes\": {}}\n                    it = packages[itkey]\n                elif triple.o == \"TopicLink\":\n                    links = uml[\"topiclinks\"]\n                    links[itkey] = {}\n                    it = links[itkey]\n                elif triple.o == \"Property\":\n                    propKey = itkey\n                    if not classKey:\n                        print(f\"invalid property {propKey} declared out of class scope\")\n                        continue\n                    properties = classes[classKey][\"properties\"]\n                    properties[propKey] = {}\n                    it = properties[propKey]\n                else:\n                    isA = triple.o\n                    classKey = itkey\n                    classes = packages[packageKey][\"classes\"]\n                    classes[itkey] = {\"isA\": isA, \"properties\": {}}\n                    it = classes[itkey]\n            elif triple.o == \"it\":\n                if triple.p == \"addsTo\":\n                    # @TODO might note be redundant but\n                    # declaring a default\n                    # redundant forward declaration\n                    pass\n                elif triple.p == \"context\":\n                    parentKey = triple.s\n                    packages[parentKey][\"classes\"][classKey] = classes[classKey]\n                    pass\n                elif triple.p == \"topic\":\n                    parentKey = triple.s\n                    classes[parentKey][\"properties\"][propKey] = properties[propKey]\n                    pass\n                else:\n                    it[triple.p] = triple.s\n        return uml\n\n    def fromDIF(self, dif) -&gt; str:\n        \"\"\"\n        create a UML from a Data Interchange\n\n        Args:\n            dif: DataInterchange - the data interchange\n\n        Returns:\n            str: the planuml markup\n\n        \"\"\"\n        umlDict = self.asUmlDict(dif)\n        self.uml = self.fromUmlDict(umlDict)\n        return\n\n    def fromUmlDict(self, umlDict: Dict) -&gt; str:\n        \"\"\"\n        convert the given umlDict Dict to a plantuml string\n\n        Args:\n            umlDict(Dict): the dictionary of packages,classes and properties\n\n        Returns:\n            str: the planuml markup\n        \"\"\"\n        uml = \"\"\n        if self.title is not None:\n            if self.copyRight is None:\n                copyRight = \"\"\n            else:\n                copyRight = \"\\n%s\" % self.copyRight\n            uml += f\"title\\n{self.title}{copyRight}\\nend title\\n\"\n        packages = umlDict[\"packages\"]\n        for packageKey in packages.keys():\n            package = packages[packageKey]\n            uml += f\"package {package['name']} {{\\n\"\n            for classKey in package[\"classes\"]:\n                uclass = package[\"classes\"][classKey]\n                className = uclass.get(\"name\", classKey)\n                isA = uclass[\"isA\"]\n                if isA != \"Topic\":\n                    extends = f\"extends {isA} \"\n                else:\n                    extends = \"\"\n                uml += f\"  class {className} {extends}{{\\n\"\n                for propKey in uclass[\"properties\"]:\n                    prop = uclass[\"properties\"][propKey]\n                    uml += f\"    {prop['name']}:{prop['type']}\\n\"\n                uml += \"  }\\n\"\n                if \"documentation\" in uclass:\n                    doc = uclass[\"documentation\"]\n                    doc = self.multi_line_doc(doc, self.doc_width)\n                    uml += f\"\"\"Note top of {className}\n{doc}\nEnd note\n\"\"\"\n            uml += \"}\\n\"\n\n        links = umlDict[\"topiclinks\"]\n        for linkKey in links.keys():\n            link = links[linkKey]\n            sourceMany = \"*\" if link[\"sourceMultiple\"] else \"1\"\n            targetMany = \"*\" if link[\"targetMultiple\"] else \"1\"\n            sourceRole = link[\"sourceRole\"] if \"sourceRole\" in link else \"\"\n            targetRole = link[\"targetRole\"] if \"targetRole\" in link else \"\"\n            source = link[\"source\"]\n            target = link[\"target\"]\n            uml += f'{source} \"{sourceRole} {sourceMany}\" -- \"{targetRole} {targetMany}\" {target}\\n'\n\n        if self.withSkin:\n            uml += PlantUml.skinparams\n        return uml\n</code></pre>"},{"location":"#meta.uml.PlantUml.__init__","title":"<code>__init__(copyRight=None, title=None, debug=False, withSkin=True, withAt=False, doc_width=40)</code>","text":"<p>Constructor</p> Source code in <code>meta/uml.py</code> <pre><code>def __init__(\n    self,\n    copyRight=None,\n    title=None,\n    debug=False,\n    withSkin: bool = True,\n    withAt: bool = False,\n    doc_width: int = 40,\n):\n    \"\"\"\n    Constructor\n    \"\"\"\n    self.debug = debug\n    self.withSkin = withSkin\n    self.withAt = withAt\n    self.uml = \"\"\n    self.title = title\n    self.copyRight = copyRight\n    self.doc_width = doc_width\n</code></pre>"},{"location":"#meta.uml.PlantUml.asUmlDict","title":"<code>asUmlDict(dif)</code>","text":"<p>return the given DataInterchange as an UML Dict</p> Source code in <code>meta/uml.py</code> <pre><code>def asUmlDict(self, dif):\n    \"\"\"\n    return the given DataInterchange as an UML Dict\n    \"\"\"\n    uml = {\"packages\": {}, \"topiclinks\": {}}\n    classKey = None\n    classes = {}\n    for _i, triple in enumerate(dif.triples):\n        if self.debug:\n            print(triple)\n        if triple.p == \"isA\":\n            itkey = triple.s\n            if triple.o == \"Context\":\n                packageKey = itkey\n                packages = uml[\"packages\"]\n                packages[itkey] = {\"classes\": {}}\n                it = packages[itkey]\n            elif triple.o == \"TopicLink\":\n                links = uml[\"topiclinks\"]\n                links[itkey] = {}\n                it = links[itkey]\n            elif triple.o == \"Property\":\n                propKey = itkey\n                if not classKey:\n                    print(f\"invalid property {propKey} declared out of class scope\")\n                    continue\n                properties = classes[classKey][\"properties\"]\n                properties[propKey] = {}\n                it = properties[propKey]\n            else:\n                isA = triple.o\n                classKey = itkey\n                classes = packages[packageKey][\"classes\"]\n                classes[itkey] = {\"isA\": isA, \"properties\": {}}\n                it = classes[itkey]\n        elif triple.o == \"it\":\n            if triple.p == \"addsTo\":\n                # @TODO might note be redundant but\n                # declaring a default\n                # redundant forward declaration\n                pass\n            elif triple.p == \"context\":\n                parentKey = triple.s\n                packages[parentKey][\"classes\"][classKey] = classes[classKey]\n                pass\n            elif triple.p == \"topic\":\n                parentKey = triple.s\n                classes[parentKey][\"properties\"][propKey] = properties[propKey]\n                pass\n            else:\n                it[triple.p] = triple.s\n    return uml\n</code></pre>"},{"location":"#meta.uml.PlantUml.atIt","title":"<code>atIt(markup)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>markup(str)</code> <p>the markup</p> required <p>Returns:     str: markup with @startuml and @enduml</p> Source code in <code>meta/uml.py</code> <pre><code>    def atIt(self, markup: str):\n        \"\"\"\n        Args:\n            markup(str): the markup\n        Returns:\n            str: markup with @startuml and @enduml\n        \"\"\"\n        if not self.withAt:\n            return markup\n        at_markup = f\"\"\"@startuml\n{markup}\n@enduml\"\"\"\n        return at_markup\n</code></pre>"},{"location":"#meta.uml.PlantUml.fromDIF","title":"<code>fromDIF(dif)</code>","text":"<p>create a UML from a Data Interchange</p> <p>Parameters:</p> Name Type Description Default <code>dif</code> <p>DataInterchange - the data interchange</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the planuml markup</p> Source code in <code>meta/uml.py</code> <pre><code>def fromDIF(self, dif) -&gt; str:\n    \"\"\"\n    create a UML from a Data Interchange\n\n    Args:\n        dif: DataInterchange - the data interchange\n\n    Returns:\n        str: the planuml markup\n\n    \"\"\"\n    umlDict = self.asUmlDict(dif)\n    self.uml = self.fromUmlDict(umlDict)\n    return\n</code></pre>"},{"location":"#meta.uml.PlantUml.fromUmlDict","title":"<code>fromUmlDict(umlDict)</code>","text":"<p>convert the given umlDict Dict to a plantuml string</p> <p>Parameters:</p> Name Type Description Default <code>umlDict(Dict)</code> <p>the dictionary of packages,classes and properties</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the planuml markup</p> Source code in <code>meta/uml.py</code> <pre><code>    def fromUmlDict(self, umlDict: Dict) -&gt; str:\n        \"\"\"\n        convert the given umlDict Dict to a plantuml string\n\n        Args:\n            umlDict(Dict): the dictionary of packages,classes and properties\n\n        Returns:\n            str: the planuml markup\n        \"\"\"\n        uml = \"\"\n        if self.title is not None:\n            if self.copyRight is None:\n                copyRight = \"\"\n            else:\n                copyRight = \"\\n%s\" % self.copyRight\n            uml += f\"title\\n{self.title}{copyRight}\\nend title\\n\"\n        packages = umlDict[\"packages\"]\n        for packageKey in packages.keys():\n            package = packages[packageKey]\n            uml += f\"package {package['name']} {{\\n\"\n            for classKey in package[\"classes\"]:\n                uclass = package[\"classes\"][classKey]\n                className = uclass.get(\"name\", classKey)\n                isA = uclass[\"isA\"]\n                if isA != \"Topic\":\n                    extends = f\"extends {isA} \"\n                else:\n                    extends = \"\"\n                uml += f\"  class {className} {extends}{{\\n\"\n                for propKey in uclass[\"properties\"]:\n                    prop = uclass[\"properties\"][propKey]\n                    uml += f\"    {prop['name']}:{prop['type']}\\n\"\n                uml += \"  }\\n\"\n                if \"documentation\" in uclass:\n                    doc = uclass[\"documentation\"]\n                    doc = self.multi_line_doc(doc, self.doc_width)\n                    uml += f\"\"\"Note top of {className}\n{doc}\nEnd note\n\"\"\"\n            uml += \"}\\n\"\n\n        links = umlDict[\"topiclinks\"]\n        for linkKey in links.keys():\n            link = links[linkKey]\n            sourceMany = \"*\" if link[\"sourceMultiple\"] else \"1\"\n            targetMany = \"*\" if link[\"targetMultiple\"] else \"1\"\n            sourceRole = link[\"sourceRole\"] if \"sourceRole\" in link else \"\"\n            targetRole = link[\"targetRole\"] if \"targetRole\" in link else \"\"\n            source = link[\"source\"]\n            target = link[\"target\"]\n            uml += f'{source} \"{sourceRole} {sourceMany}\" -- \"{targetRole} {targetMany}\" {target}\\n'\n\n        if self.withSkin:\n            uml += PlantUml.skinparams\n        return uml\n</code></pre>"},{"location":"#meta.uml.PlantUml.multi_line_doc","title":"<code>multi_line_doc(doc, width)</code>","text":"<p>Returns the given documentation as a multiline string with a limited length per line. Lines are broken at whitespace.</p> <p>Parameters:</p> Name Type Description Default <code>doc(str)</code> <p>the documentation to wrap</p> required <code>width(int)</code> <p>The maximum length of each line.</p> required <p>Returns:     str: the  Multiline string.</p> Source code in <code>meta/uml.py</code> <pre><code>def multi_line_doc(self, doc: str, width: int) -&gt; str:\n    \"\"\"\n    Returns the given documentation as a multiline string with a limited length per line.\n    Lines are broken at whitespace.\n\n    Args:\n        doc(str): the documentation to wrap\n        width(int): The maximum length of each line.\n    Returns:\n        str: the  Multiline string.\n    \"\"\"\n    text = \"\\n\".join(textwrap.wrap(doc, width=width))\n    return text\n</code></pre>"},{"location":"#meta.version","title":"<code>version</code>","text":"<p>Created on 2023-02-19</p> <p>@author: wf</p>"},{"location":"#meta.version.Version","title":"<code>Version</code>","text":"<p>               Bases: <code>object</code></p> <p>Version handling for pyMetaModel</p> Source code in <code>meta/version.py</code> <pre><code>class Version(object):\n    \"\"\"\n    Version handling for pyMetaModel\n    \"\"\"\n\n    name = \"pyMetaModel\"\n    description = \"pyMetaModel: MetaModel for Knowledge Graphs\"\n    version = meta.__version__\n    date = \"2022-11-30\"\n    updated = \"2024-01-15\"\n    authors = \"Wolfgang Fahl\"\n    doc_url = \"https://wiki.bitplan.com/index.php/pyMetaModel\"\n    chat_url = \"https://github.com/WolfgangFahl/pyMetaModel/discussions\"\n    cm_url = \"https://github.com/WolfgangFahl/pyMetaModel\"\n    license = f\"\"\"Copyright 2022-2024 contributors. All rights reserved.\n  Licensed under the Apache License 2.0\n  http://www.apache.org/licenses/LICENSE-2.0\n  Distributed on an \"AS IS\" basis without warranties\n  or conditions of any kind, either express or implied.\"\"\"\n    longDescription = f\"\"\"{name} version {version}\n{description}\n  Created by {authors} on {date} last updated {updated}\"\"\"\n</code></pre>"}]}